// RobotBuilder Version: 1.0
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// Java from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.
package org.usfirst.frc696.RobotBuilderredemption.subsystems;
import org.usfirst.frc696.RobotBuilderredemption.RobotMap;
import org.usfirst.frc696.RobotBuilderredemption.commands.*;
import edu.wpi.first.wpilibj.*;
import edu.wpi.first.wpilibj.command.Subsystem;
import org.usfirst.frc696.RobotBuilderredemption.UtilClasses.CustomPID;
import org.usfirst.frc696.RobotBuilderredemption.UtilClasses.Util;
/**
 *
 */
public class DriveTrain extends Subsystem {
    public byte[] hotness = {1};
    double rightDrivePow = 0.0;
    double leftDrivePow = 0.0;
    double rightSpeed = 0.0;
    double leftSpeed = 0.0;
    double rightSpeedError = 0.0;
    double leftSpeedError = 0.0;
    boolean shifted = false;
    boolean oldShifted = false;
    public CustomPID turnController = new CustomPID(0.03, 0, 0.02);
    public CustomPID moveController = new CustomPID(0.003, 0, 0.002);
    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS
    SpeedController frontLeftTalon = RobotMap.driveTrainfrontLeftTalon;
    SpeedController rearLeftTalon = RobotMap.driveTrainrearLeftTalon;
    SpeedController frontRightTalon = RobotMap.driveTrainfrontRightTalon;
    SpeedController rearRightTalon = RobotMap.driveTrainrearRightTalon;
    RobotDrive robotDrive = RobotMap.driveTrainRobotDrive;
    Gyro gyro = RobotMap.driveTrainGyro;
    Encoder rightEncoder = RobotMap.driveTrainrightEncoder;
    Encoder leftEncoder = RobotMap.driveTrainleftEncoder;
    Solenoid shiftingSolenoid = RobotMap.driveTrainshiftingSolenoid;
    Compressor compressor = RobotMap.driveTraincompressor;
    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS
    // Put methods for controlling this subsystem
    // here. Call these from Commands.
    public void initDefaultCommand() {
        compressor.start();
        // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DEFAULT_COMMAND
    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DEFAULT_COMMAND
        // Set the default command for a subsystem here.
        //setDefaultCommand(new MySpecialCommand());
    }
    public void tankDrive(double leftJoystickValue, double rightJoystickValue) {
        robotDrive.tankDrive(leftJoystickValue, rightJoystickValue);
        
    }
    public void arcadeDrive(double move, double turn) {
        robotDrive.arcadeDrive(move, turn);
    }
    public boolean arcadePIDDrive(double speed, double distance, double turn) {
        leftEncoder.setDistancePerPulse(0.09162978572970230278849376534565);
        rightEncoder.setDistancePerPulse(0.09162978572970230278849376534565);
        turnController.update(turn, gyro.getAngle());
        shiftingSolenoid.set(false);
        //moveController.update(speed,(leftEncoder.getRate()+ rightEncoder.getRate())/2);
        //System.out.print("moveoutput:  " + moveController.getOutput());
        //System.out.println("encoderGets:  " + leftEncoder.getDistance()+ "  "+ rightEncoder.getDistance()); 
        //System.out.println(leftEncoder.getRate() +"   " +rightEncoder.getRate());
        System.out.println("speed   " + speed);
        if (distance > 0) {
            robotDrive.arcadeDrive(speed, -turnController.getOutput());
            System.out.println(leftEncoder.getDistance() + "  " + rightEncoder.getDistance() + "  " + gyro.getAngle());
            System.out.println(leftEncoder.getDistance()/200 + "  " + distance);
            return ((leftEncoder.getDistance()) > distance);//&& (gyro.getAngle()-turn)/2<0.1;
        } else {
            robotDrive.arcadeDrive(-speed, -turnController.getOutput());//-turnController.getOutput());
            return ((leftEncoder.getDistance()) < distance);//&& (gyro.getAngle()-turn)/2<0.1;
        }
    }
    public void shiftingDrive(double leftWantedSpeed, double rightWantedSpeed) {//not done yet
        //this code takes in wanted speeds and drives the motors while autoShifting
        rightDrivePow = 0.0;
        leftDrivePow = 0.0;
        rightSpeed = Util.abs(rightEncoder.getRate());
        leftSpeed = Util.abs(leftEncoder.getRate());
        rightSpeedError = rightWantedSpeed - rightSpeed;
        leftSpeedError = leftWantedSpeed - leftSpeed;
        if ((leftSpeed > 6.0) && (rightSpeed > 6.0)) {//7.5 ft/sec is the fastest low gear can [theoreticly] go
            System.out.println("Shifted Forward");
            //System.out.println("Shifted Forward");
            RobotMap.driveTrainshiftingSolenoid.set(false);//switch to high gear
            rightDrivePow = rightWantedSpeed / 17;
            leftDrivePow = leftWantedSpeed / 17;
            shifted = true;
            //rightDrivePow = right
        } else if ((leftSpeed < 4.5) && (rightSpeed < 4.5)) {
            System.out.println("Shifted Reverse");
            RobotMap.driveTrainshiftingSolenoid.set(true);//switch to low gear
            rightDrivePow = rightWantedSpeed / 15;
            leftDrivePow = leftWantedSpeed / 15;
            shifted = false;
        } else {
            rightDrivePow = rightWantedSpeed / 17;
            leftDrivePow = leftWantedSpeed / 17;
        }
        /*if((leftWantedSpeed>7.0)&&(rightWantedSpeed>7.0)){//7.5 ft/sec is the fastest low gear can [theoreticly] go
         shiftingSolenoid.set(true);//switch to high gear
         }else if((leftWantedSpeed<6.0)&&(rightWantedSpeed<6.0)){
         shiftingSolenoid.set(false);//switch to low gear
         * 
         }*/
        /*rightDrivePow += rightSpeedError/10;
         leftDrivePow += leftSpeedError/10;*/
        System.out.print("Speed Error   " + leftSpeedError + "   " + rightSpeedError + "   Pow  " + leftDrivePow + "   " + rightDrivePow + "   WantedSpeed  " + rightWantedSpeed + "Rate   ");
        //System.out.print("Speed Error   " + leftSpeedError+"   "+rightSpeedError+"   Pow  "+leftDrivePow+"   "+rightDrivePow+"   WantedSpeed  " +rightWantedSpeed + "Rate   ");
        if ((shifted && (!oldShifted)) || ((!shifted) && (oldShifted))) {
            leftDrivePow = 0;
            rightDrivePow = 0;
        }
        /*rightDrivePow += Util.constrain(((rightSpeedError)/(Util.constrain(Util.abs(rightSpeed),1,5)))/10,-1,1);
         leftDrivePow += Util.constrain(((leftSpeedError)/(Util.constrain(Util.abs(leftSpeed),1,5)))/10,-1,1);*/
        oldShifted = shifted;
        robotDrive.tankDrive(leftDrivePow, rightDrivePow);
    }
    public void stop() {
        robotDrive.drive(0, 0);
    }
    public void resetEncoders() {
        leftEncoder.reset();
        rightEncoder.reset();
    }
    public double getGyro() {
        return gyro.getAngle();
    }
    public void resetGyro(){
       gyro.reset();
    }
}

// RobotBuilder Version: 1.0
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// Java from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.
package org.usfirst.frc696.RobotBuilderredemption;
import edu.wpi.first.wpilibj.DriverStation;
import edu.wpi.first.wpilibj.DriverStationEnhancedIO;
import edu.wpi.first.wpilibj.IterativeRobot;
import edu.wpi.first.wpilibj.Joystick;
import edu.wpi.first.wpilibj.Timer;
import edu.wpi.first.wpilibj.command.Command;
import edu.wpi.first.wpilibj.command.Scheduler;
import edu.wpi.first.wpilibj.livewindow.LiveWindow;
import org.usfirst.frc696.RobotBuilderredemption.UtilClasses.*;
import org.usfirst.frc696.RobotBuilderredemption.commands.*;
import org.usfirst.frc696.RobotBuilderredemption.subsystems.*;
/**
 * The VM is configured to automatically run this class, and to call the
 * functions corresponding to each mode, as described in the IterativeRobot
 * documentation. If you change the name of this class or the package after
 * creating this project, you must also update the manifest file in the resource
 * directory.
 */
public class Robot extends IterativeRobot {
    boolean paradeMode = false;
    boolean frontPickupDown = false;
    boolean backPickupDown = false;
    boolean[] button = new boolean[20];
    boolean[] oldButton = new boolean[20];
    boolean fastTurn = false;
    boolean ejected = false;
    boolean trussPos = false;
    boolean trussFire = false;
    double[] analog = new double[20];
    double[] oldAnalog = new double[20];
    double wheel = 0.0;
    double stick = 0.0;
    double rightDriveVal = 0.0;
    double leftDriveVal = 0.0;
    double rightDriveSetVal = 0.0;
    double leftDriveSetVal = 0.0;
    double openFireDelay = 1.5;
    double switchSaftey = 2;
    double pickUpRollerRocker = 0;
    double shiftingRocker = 0;
    int trussShot = 0;
    boolean pickUpDown = false;
    boolean shifted = true;
    boolean firing = false;
    boolean oldFastTurn = false;
    double LEDRate = 0.02;
    double pinkIncrease = LEDRate;
    double greenIncrease = 0.0;
    double pinkLight = 0.96;
    double greenLight = 0.0;
    double blueLight = 0.0;
    DriverStationEnhancedIO cypress = DriverStation.getInstance().getEnhancedIO();
    Joystick joyStick = new Joystick(1);
    Timer pickUpTimer = new Timer();
    Timer ejectTimer = new Timer();
    Timer fireTimer = new Timer();
    Timer trussFireTimer = new Timer();
    Command autonomousCommand;
    public static OI oi;
    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS
    public static DriveTrain driveTrain;
    public static pickUp pickUp;
    public static frontPickup frontPickup;
    public static shooter shooter;
    public static LEDs lEDs;
    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS
    /**
     * This function is run when the robot is first started up and should be
     * used for any initialization code.
     */
    public void robotInit() {
        
        
        
        RobotMap.init();
        // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTRUCTORS
        driveTrain = new DriveTrain();
        pickUp = new pickUp();
        frontPickup = new frontPickup();
        shooter = new shooter();
        lEDs = new LEDs();
        
        Robot.driveTrain.server.setPort(1180);
        Robot.driveTrain.server.start();
        Robot.driveTrain.server.reset();
        Robot.driveTrain.server.startSamplingCounts();
        
    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTRUCTORS
        // This MUST be here. If the OI creates Commands (which it very likely
        // will), constructing it during the construction of CommandBase (from
        // which commands extend), subsystems are not guaranteed to be
        // yet. Thus, their requires() statements may grab null pointers. Bad
        // news. Don't move it.
        oi = new OI();
        // instantiate the command used for the autonomous period
        // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=AUTONOMOUS
        autonomousCommand = new autonomousCode();
    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=AUTONOMOUS
    }
    public void autonomousInit() {
        autonomousCommand = new autonomousCode();
        // schedule the autonomous command (example)
        if (autonomousCommand != null) {
            autonomousCommand.start();
        }
    }
    /**
     * This function is called periodically during autonomous
     */
    public void autonomousPeriodic() {
        Scheduler.getInstance().run();
    }
    public void teleopInit() {
        // This makes sure that the autonomous stops running when
        // teleop starts running. If you want the autonomous to 
        // continue until interrupted by another command, remove
        // this line or comment it out.
        if (autonomousCommand != null) {
            autonomousCommand.cancel();
        }
        RobotMap.driveTraincompressor.start();
        RobotMap.driveTrainrightEncoder.start();
        RobotMap.driveTrainleftEncoder.start();
        RobotMap.pickUpthreeInSolenoid.set(false);
        RobotMap.pickUptwoInSolenoid.set(false);
        RobotMap.driveTrainrightEncoder.setDistancePerPulse(0.005026548245743669181540229413247);//4 inches dia
        RobotMap.driveTrainleftEncoder.setDistancePerPulse(0.005026548245743669181540229413247);//4 inches dia
        RobotMap.driveTrainRobotDrive.tankDrive(0, 0);
        RobotMap.lEDsred.setPWMRate(15000);
        RobotMap.lEDsgreen.setPWMRate(15000);
        RobotMap.lEDsblue.setPWMRate(15000);
        RobotMap.lEDsred.enablePWM(1.0);
        RobotMap.lEDsblue.enablePWM(0.5);
        RobotMap.lEDsgreen.enablePWM(0.0);
    }
    /**
     * This function is called periodically during operator control
     */
    public void teleopPeriodic() {
        System.out.println("cheesy:   "+Robot.driveTrain.server.getLeftStatus()+ "  " + Robot.driveTrain.server.getRightStatus());
            
        if (!paradeMode) {
            
            
            RobotMap.shooterejectSolenoid.set(false);
            RobotMap.pickUpthreeInSolenoid.set(false);
            RobotMap.pickUptwoInSolenoid.set(false);
            RobotMap.lEDsred.updateDutyCycle(pinkLight);
            RobotMap.lEDsblue.updateDutyCycle(pinkLight / 2);
            greenLight = greenLight + greenIncrease;
            pinkLight += pinkIncrease;
            RobotMap.lEDsgreen.updateDutyCycle(greenLight);
            if (pinkLight > 1.0) {
                pinkIncrease = -LEDRate;
            }
            if (pinkLight < 0.0) {
                pinkLight = 0.0;
                pinkIncrease = 0;
                greenIncrease = LEDRate;
            }
            if (greenLight > 1.0) {
                greenIncrease = -LEDRate;
            }
            if (greenLight < 0.0) {
                greenLight = 0.0;
                greenIncrease = 0;
                pinkIncrease = LEDRate;
            }
            for (int i = 1; i <= 12; i++) {
                button[i] = joyStick.getRawButton(i);
            }
            for (int i = 1; i <= 4; i++) {
                analog[i] = joyStick.getRawAxis(i);
            }
            if (button[10] && (!oldButton[10])) {
                shifted = !shifted;
            }
            fastTurn = button[10];
            stick = -joyStick.getRawAxis(2);
            wheel = analog[1];
            pickUpRollerRocker = analog[4];
            shiftingRocker = analog[3];
            //pickupmotors controller
            RobotMap.pickUpbackPickUpLeft.set(-pickUpRollerRocker);
            RobotMap.pickUpbackPickUpRight.set(pickUpRollerRocker);
            if (button[1]) {
                RobotMap.frontPickupLeft.set(-1);
                RobotMap.frontPickupRight.set(1);
            } else if (button[3]) {
                RobotMap.frontPickupLeft.set(1);
                RobotMap.frontPickupRight.set(-1);
            } else {
                    RobotMap.frontPickupLeft.set(0.0);
                    RobotMap.frontPickupRight.set(0.0);
            }
        //drive code
            if (fastTurn) {
                rightDriveVal = Util.signOf(stick) * wheel * -4;
                leftDriveVal = Util.signOf(stick) * wheel * 4;
            } else {
                if (stick >= 0) {
                    rightDriveVal = (stick) + ((-1 * (wheel * (1.15 - stick))) / 1.3);
                    leftDriveVal = stick + ((wheel * (1.15 - stick)) / 1.3);
                } else {//switch left and right driveval around if want like a car
                    leftDriveVal = (stick) + (((wheel * (1.15 + (stick)))) / 1.3);
                    rightDriveVal = (stick) + ((-1 * (wheel * (1.15 + (stick)))) / 1.3);
                }
            }
            rightDriveSetVal = Util.smooth(rightDriveVal, rightDriveSetVal, 2);
            leftDriveSetVal = Util.smooth(leftDriveVal, leftDriveSetVal, 2);
            pickUpDown = button[2];
            RobotMap.frontPickupdeploy.set(button[2]);
            if (button[6] && (!oldButton[6])) {
                ejected = !ejected;
            }
            System.out.println((!RobotMap.shooterchoochooLimitSwitchLeft.get()) + "   " + (!RobotMap.shooterchoochooLimitSwitchLeft.get()));
            if (trussFire) {
                RobotMap.pickUpthreeInSolenoid.set(true);
                if ((trussFireTimer.get() > 0.1)) {
                    RobotMap.shooterchoochooLeft.set(0.7);
                    RobotMap.shooterchoochooRight.set(-0.7);
                    if (((trussFireTimer.get() > 0.3) && ((RobotMap.shooterchoochooLimitSwitchLeft.get()) || (RobotMap.shooterchoochooLimitSwitchRight.get()))) || (trussFireTimer.get() > 3)) {
                        System.out.println("Stopping");
                        RobotMap.shooterchoochooLeft.set(0);
                        RobotMap.shooterchoochooRight.set(0);
                        trussFire = false;
                        trussShot = 0;
                        trussFireTimer.reset();
                    }
                }
            }
            RobotMap.shooterejectSolenoid.set(ejected);
            if (button[4] && (!oldButton[4])) {
                trussPos = !trussPos;
            }
            RobotMap.pickUpthreeInSolenoid.set(trussPos);
            if (button[5] && (!oldButton[5])) {
                pickUpTimer.start();
                RobotMap.pickUptwoInSolenoid.set(true);
            }
            pickUpDown = button[5];
            if (pickUpDown) {
                RobotMap.pickUptwoInSolenoid.set(true);
                System.out.println(pickUpTimer.get());
                if (pickUpTimer.get() > 0.25) {
                    RobotMap.pickUpthreeInSolenoid.set(true);
                }
            }
            System.out.println(!RobotMap.shooterchoochooLimitSwitchLeft.get() + "   " + (!RobotMap.shooterchoochooLimitSwitchRight.get()));
            if (button[7] && (!oldButton[7])) {
                firing = true;
                System.out.println("pressed");
                fireTimer.start();
            }
            if (firing) {
            //RobotMap.pickUpthreeInSolenoid.set(true);
                //RobotMap.catchercatcherOpen.set(true);
                if ((fireTimer.get() > 0.0)) {
                    RobotMap.shooterchoochooLeft.set(0.85);
                    RobotMap.shooterchoochooRight.set(-0.85);
                    if (((fireTimer.get() > 0.25) && ((RobotMap.shooterchoochooLimitSwitchLeft.get()) || (RobotMap.shooterchoochooLimitSwitchRight.get()))) || (fireTimer.get() > 3)) {
                        System.out.println("Stopping");
                        RobotMap.shooterchoochooLeft.set(0);
                        RobotMap.shooterchoochooRight.set(0);
                        firing = false;
                        fireTimer.reset();
                    }
                }
            }
            if (button[6]) {
                RobotMap.shooterejectSolenoid.set(true);
                RobotMap.pickUpbackPickUpRight.set(0.8);
                RobotMap.pickUpbackPickUpLeft.set(-0.8);
            }else{
                RobotMap.shooterejectSolenoid.set(false);
                RobotMap.pickUpbackPickUpRight.set(0);
                RobotMap.pickUpbackPickUpLeft.set(0);
            }
            oldFastTurn = fastTurn;
            if (button[9] && (!oldButton[9])) {
                trussShot++;
            }
            if (button[8] && (!oldButton[8])) {
                trussShot = 0;
            }
            if (trussShot == 1) {
                RobotMap.pickUpthreeInSolenoid.set(true);
            }
            if ((trussShot == 2) && (button[9])) {
                trussFire = true;
                trussFireTimer.start();
            }
            for (int i = 1; i <= 12; i++) {
                oldButton[i] = joyStick.getRawButton(i);
            }
            for (int i = 1; i <= 4; i++) {
                oldAnalog[i] = joyStick.getRawAxis(i);
            }
            Robot.driveTrain.tankDrive(leftDriveSetVal, rightDriveSetVal);
            System.out.println(RobotMap.driveTrainleftEncoder.getRate() + "   " + RobotMap.driveTrainrightEncoder.getRate());
            RobotMap.driveTrainshiftingSolenoid.set(shifted);
            if (shiftingRocker == 0) {
                Robot.driveTrain.shiftingDrive(leftDriveSetVal * 17, rightDriveSetVal * 17);
            } else if (shiftingRocker < 0) {
                RobotMap.driveTrainshiftingSolenoid.set(true);
            } else {
                RobotMap.driveTrainshiftingSolenoid.set(false);
            }
        } else {
            RobotMap.shooterejectSolenoid.set(false);              //LED stuff
            RobotMap.pickUpthreeInSolenoid.set(false);
            RobotMap.pickUptwoInSolenoid.set(false);
            RobotMap.lEDsred.updateDutyCycle(pinkLight);
            RobotMap.lEDsblue.updateDutyCycle(pinkLight / 2);
            greenLight = greenLight + greenIncrease;
            pinkLight += pinkIncrease;
            RobotMap.lEDsgreen.updateDutyCycle(greenLight);
            if (pinkLight > 1.0) {
                pinkIncrease = -LEDRate;
            }
            if (pinkLight < 0.0) {
                pinkLight = 0.0;
                pinkIncrease = 0;
                greenIncrease = LEDRate;
            }
            if (greenLight > 1.0) {
                greenIncrease = -LEDRate;
            }
            if (greenLight < 0.0) {
                greenLight = 0.0;
                greenIncrease = 0;
                pinkIncrease = LEDRate;
            }                                                                           //LEDstuff ends
            for (int i = 1; i <= 12; i++) {
                button[i] = joyStick.getRawButton(i);
            }
            for (int i = 1; i <= 4; i++) {
                analog[i] = joyStick.getRawAxis(i);
            }
            if (button[10] && (!oldButton[10])) {
                shifted = !shifted;
            }
        //drive code
            Robot.driveTrain.tankDrive(-joyStick.getY(), -joyStick.getThrottle());
        //pickupRollers start
            if (button[6]) {
                RobotMap.frontPickupLeft.set(-1.0);
                RobotMap.frontPickupRight.set(1.0);
            } else if (button[8]) {
                RobotMap.frontPickupLeft.set(1.0);
                RobotMap.frontPickupRight.set(-1.0);
            } else {
                RobotMap.frontPickupLeft.set(0);
                RobotMap.frontPickupRight.set(0);
            }
            if (button[5]) {
                RobotMap.pickUpbackPickUpLeft.set(1.0);
                RobotMap.pickUpbackPickUpRight.set(-1.0);
            } else if (button[7]) {
                RobotMap.pickUpbackPickUpLeft.set(-1.0);
                RobotMap.pickUpbackPickUpRight.set(1.0);
            } else if (button[2]) {
                RobotMap.shooterejectSolenoid.set(true);
                RobotMap.pickUpbackPickUpRight.set(0.8);
                RobotMap.pickUpbackPickUpLeft.set(-0.8);
            } else {
                RobotMap.pickUpbackPickUpLeft.set(0);
                RobotMap.pickUpbackPickUpRight.set(0);
            }
       //pickupRollers end
            //pickupTogglingStart
            if (button[4] && !oldButton[4]) {
                frontPickupDown = !frontPickupDown;
            }
            if (button[3] && !oldButton[3]) {
                backPickupDown = !backPickupDown;
                pickUpTimer.reset();
                pickUpTimer.start();
            }
            RobotMap.frontPickupdeploy.set(frontPickupDown);
            if (backPickupDown) {
                RobotMap.pickUptwoInSolenoid.set(true);
                if (pickUpTimer.get() > 0.25) {
                    RobotMap.pickUpthreeInSolenoid.set(true);
                }
            }
        //pickupToggling end
            if (button[1] && (!oldButton[1])) {
                firing = true;
                fireTimer.start();
            }
            if (firing) {
            //RobotMap.pickUpthreeInSolenoid.set(true);
                //RobotMap.catchercatcherOpen.set(true);
                if ((fireTimer.get() > 0.0)) {
                    RobotMap.shooterchoochooLeft.set(0.85);
                    RobotMap.shooterchoochooRight.set(-0.85);
                    if (((fireTimer.get() > 0.25) && ((RobotMap.shooterchoochooLimitSwitchLeft.get()) || (RobotMap.shooterchoochooLimitSwitchRight.get()))) || (fireTimer.get() > 3)) {
                        RobotMap.shooterchoochooLeft.set(0);
                        RobotMap.shooterchoochooRight.set(0);
                        firing = false;
                        fireTimer.reset();
                    }
                }
            }
            for (int i = 1; i <= 12; i++) {
                oldButton[i] = joyStick.getRawButton(i);
            }
            for (int i = 1; i <= 4; i++) {
                oldAnalog[i] = joyStick.getRawAxis(i);
            }
            RobotMap.driveTrainshiftingSolenoid.set(false);
            
        }
    }
    /*
     * This function called periodically during test mode
     */
    public void testPeriodic() {
        LiveWindow.run();
    }
    public void getCypress() {
        try {
            stick = Util.smoothDeadZone(Util.map(cypress.getAnalogIn(1), 0, 3.3, 1, -1), -0.15, 0.02, -1, 1, 0);//-0.1 lower band if no work
            //throttle = Util.map(cypress.getAnalogIn(1), 0, 3.3, 1, -1);
        } catch (DriverStationEnhancedIO.EnhancedIOException ex) {
            stick = 0;
            System.out.println("Left Joystick error");
        }
        try {
            wheel = Util.constrain(Util.smoothDeadZone(Util.map(cypress.getAnalogIn(8), 0.7, 2.6, 1, -1), -0.07, 0.07, -1, 1, 0), -1, 1);
        } catch (DriverStationEnhancedIO.EnhancedIOException ex) {
            wheel = 0;
            System.out.println("Right Joystick error");
        }
        try {
            fastTurn = !cypress.getDigital(12);
        } catch (DriverStationEnhancedIO.EnhancedIOException ex) {
            fastTurn = false;
            System.out.println("Right Joystick error");
        }
    }
}
